# Generate C++ and MATLAB wrapper for wcslib

import os, glob, time, json, argparse
from datetime import datetime


#--------------------------- Utility Functions ---------------------------

# Log lines are cached in this list, to allow 'undo' of logging if we
# decide later that it should be ommited.
log_lines = None

# Log message to file
logfile = None
def log(msg, dt = False):
    global logfile, log_lines
    if msg == '': dt = False
    if dt: msg = datetime.now().strftime('%d/%m/%y %H:%M:%S.%f')[:-3] + ' ' + msg
    print(msg)
    if log_lines != None:
        log_lines.append(msg)
    elif logfile:
        logfile.write(msg)
        logfile.write("\n")
        logfile.flush()


def clear_log_lines():
    global log_lines
    log_lines = None


def write_log_lines():
    global log_lines
    lines = log_lines
    log_lines = None
    if lines:
        for line in lines:
            log(line)


# Run command line with timing
def run(cmdline):
    log('run: ' + cmdline)
    try:
        start = time.time()
        os.system(cmdline)
        end = time.time()
        elapsed = end - start
        log(cmdline + ' - ' + ('%.3f' % elapsed) + " seconds")
        return elapsed
    except:
        log('run: FAILED: ' + cmdline)
        return 0


# Creates folders
def mkdirs(path):
    if not os.path.exists(path):
        #log('mkdirs: ' + path)
        os.makedirs(path)


# Replace text between two tag lines, keeping the tags
def replace_between_tags(lines, start_tag, stop_tag, text):
    start_index = -1
    stop_index = -1

    for i, line in enumerate(lines):
        if line.strip() == start_tag:
            start_index = i
        elif line.strip() == stop_tag:
            stop_index = i

    new_lines = lines
    if start_index > -1 and stop_index > start_index:
        new_lines = lines[:start_index+1]
        new_lines.extend(text.split('\n'))
        new_lines.extend(lines[stop_index:])

    return new_lines


def replace_file_between_tags(target_fname, start_tag, stop_tag, fname, remove_file):

    # Read the generated text
    with open(fname) as f:
        text = f.read()

    if remove_file:
        os.remove(fname)

    # Load .h file
    with open(target_fname) as f:
        lines = f.read().splitlines()

    lines = replace_between_tags(lines, start_tag, stop_tag, text)

    # Replace file contents
    with open(target_fname, 'wt') as f:
        for line in lines:
            f.write('%s\n' % line)



# Process process_files_*.log file generated by process_files.py
def process_header(filename):
    container_struct_name = 'wcsprm'

    path, fname = os.path.split(filename)
    log('\n## ' + path)
    log(filename + '\n')

    # Load log file
    lines = []
    with open(filename) as f:
        lines = f.read().splitlines()

    # Path of cpp/h files
    cpp_path = '../cfitsio/wcslib/wcslib_class'

    # Path of Matlab class files
    matlab_filename = '../wcs_matlab/wcslibCl.m'

    # wcslib_class_props.h is INSERTED into wcslib_class_props.h between </code> tags
    props_h_fname = os.path.join(cpp_path, 'wcslib_class_props.h')
    h_file = open(props_h_fname, 'wt')

    # wcslib_class_props.cpp is #included from wcslib_class_matlab.cpp
    props_cpp_fname = os.path.join(cpp_path, 'wcslib_class_props.cpp')
    cpp_file = open(props_cpp_fname, 'wt')

    # C++ export (dll/so)
    EXPORT = 'CFITS_API'

    matlab_props = []
    prop_dtype = {}

    unhandled_props = []

    for line in lines:
        s = line.replace('\t', ' ').strip()

        # Remove commment after //
        index = s.find('//')
        if index > -1:
            s = s[:index].strip()

        # Skip empty lines
        if s == '':
            continue

        # Skip the container struct
        if s.find('{') > -1 or s.find('}') > -1:
            continue

        words = s.split(' ')
        data_type = words[0]

        # Check for 'struct'
        is_struct = False
        struct_name = ''
        if data_type == 'struct':
            # Get struct name
            struct_name = words[1]

            # Skip the container struct
            if struct_name == container_struct_name:
                continue

            # Get field name
            is_struct = True
            fields = ' '.join(words[2:])
        else:
            # Get field names
            fields = ' '.join(words[1:])

        # Split fields
        fields = fields.split(',')

        for field in fields:
            # Remove ';', ignore empty lines
            field = field.replace(';', '').strip()
            if field == '':
                continue

            dtype = data_type

            # Function
            is_func = False
            if field.find('(') > -1:
                is_func = True

            # Array
            is_array = False
            array_len = 0
            if field.find('[') > -1:
                is_array = True

            # Pointer
            is_ptr = False
            if s.find('*') > -1:
                is_ptr = True


            handled = False

            # Simple type
            len_getter_prefix = 'wcsGetPropLen_'
            getter_prefix = 'wcsGetProp_'
            setter_prefix = 'wcsSetProp_'

            macro_suffix = ''
            if dtype == 'int':
                macro_suffix = 'INT'
            elif dtype == 'double':
                macro_suffix = 'DOUBLE'
            elif dtype == 'char':
                macro_suffix = 'CHAR'

            ### Simple Type ###
            prop = field
            if not is_ptr and not is_array and not is_func and not is_struct:

                # .h - header - Getter and Setter
                getter_h_text = dtype + ' ' + EXPORT + ' ' + getter_prefix + prop + '();'
                setter_h_text = 'bool ' + EXPORT + ' ' + setter_prefix + prop + '(' + dtype + ' value);'
                h_file.write('// Get/set property: ' + prop + ' (' + dtype + ')\n')
                h_file.write(getter_h_text + '\n')
                h_file.write(setter_h_text + '\n\n')
                h_file.flush()

                # .cpp - function body - Getter and Setter
                getter_cpp_text = dtype + ' ' + getter_prefix + prop + '() { GET_PROP_' + macro_suffix + '(' + prop + '); }'
                setter_cpp_text = 'bool ' + setter_prefix + prop + '(' + dtype + ' value) { SET_PROP_' + macro_suffix + '(' + prop + ', value); }'
                cpp_file.write('// Get/set property: ' + prop + ' (' + dtype + ')\n')
                cpp_file.write(getter_cpp_text + '\n')
                cpp_file.write(setter_cpp_text + '\n\n')
                cpp_file.flush()

                matlab_props.append(prop)
                prop_dtype[prop] = dtype
                handled = True


            # String: char[]
            if not handled and is_array and not is_ptr and dtype == 'char' and not is_struct:
                field = field.split('[')[0].strip()
                prop = field

                # .h - header - Getter and Setter
                getter_h_text = EXPORT + ' char const*' + getter_prefix + prop + '();'
                setter_h_text = EXPORT + ' void ' + setter_prefix + prop + '(const char* value);'
                h_file.write('// Get/set property: ' + prop + ' (string)\n')
                h_file.write(getter_h_text + '\n')
                h_file.write(setter_h_text + '\n\n')
                h_file.flush()

                # .cpp - function body - Getter and Setter
                getter_cpp_text = 'char const* ' + getter_prefix + prop + '() { GET_PROP_STR(' + prop + '); }'
                setter_cpp_text = 'void ' + setter_prefix + prop + '(const char* value) { SET_PROP_STR(' + prop + ', value); }'
                cpp_file.write('// Get/set property: ' + prop + ' (string)\n')
                cpp_file.write(getter_cpp_text + '\n')
                cpp_file.write(setter_cpp_text + '\n\n')
                cpp_file.flush()

                matlab_props.append(prop)
                prop_dtype[prop] = dtype

                handled = True


            # Simple matrix: int* or double*
            if not handled and( is_ptr or is_array) and (dtype == 'int' or dtype == 'double') and not is_struct:
                if is_ptr:
                    field = field.replace('*', '').strip()
                    prop = field
                elif is_array:
                    tokens = field.split('[')
                    prop = tokens[0].strip()
                    tokens = tokens[1].split(']')
                    array_len = int(tokens[0].strip())

                dtype += '*'

                # .h - header - Getter and Setter
                len_getter_h_text = 'int ' + EXPORT + ' ' + len_getter_prefix + prop + '();'
                getter_h_text = 'void ' + EXPORT + ' ' + getter_prefix + prop + '(' + dtype + ' value' + ', size_t len);'
                setter_h_text = 'void ' + EXPORT + ' ' + setter_prefix + prop + '(' + dtype + ' value' + ', size_t len);'
                h_file.write('// Get/set property: ' + prop + ' (' + dtype + ')\n')
                h_file.write(len_getter_h_text + '\n')
                h_file.write(getter_h_text + '\n')
                h_file.write(setter_h_text + '\n\n')
                h_file.flush()

                # .cpp - function body - Getter and Setter
                if is_ptr:
                    len_getter_cpp_text = 'int ' + len_getter_prefix + prop + '() { GET_PROP_MAT_LEN(' + prop + '); }'
                else:
                    len_getter_cpp_text = 'int ' + len_getter_prefix + prop + '() { return ' + str(array_len) + '; }'

                getter_cpp_text = 'void ' + getter_prefix + prop + '(' + dtype + ' value, size_t len) { GET_PROP_' + macro_suffix + '_MAT(' + prop + ', value, len); }'
                setter_cpp_text = 'void ' + setter_prefix + prop + '(' + dtype + ' value, size_t len) { SET_PROP_' + macro_suffix + '_MAT(' + prop + ', value, len); }'
                cpp_file.write('// Get/set property: ' + prop + ' (' + dtype + ')\n')
                cpp_file.write(len_getter_cpp_text + '\n')
                cpp_file.write(getter_cpp_text + '\n')
                cpp_file.write(setter_cpp_text + '\n\n')
                cpp_file.flush()

                matlab_props.append(prop)
                prop_dtype[prop] = dtype

                handled = True

        if not handled and is_struct and is_ptr:
            log('not implemented yet: ' + line)

            handled = True

        if not handled and is_struct and not is_ptr:
            log('not implemented yet: ' + line)

            handled = True


        if not handled:
            unhandled_props.append((prop))

    h_file.close()
    cpp_file.close()

    log('')
    log('Unhandled fields:')
    for prop in unhandled_props:
        log(prop)
    log('')

    #--------------------------------------------- Update CPP file
    h_fname = os.path.join(cpp_path, 'wcslib_class_matlab.h')
    replace_file_between_tags(h_fname, '//<code>', '//</code>', props_h_fname, True)

    cpp_fname = os.path.join(cpp_path, 'wcslib_class_matlab.cpp')
    replace_file_between_tags(cpp_fname, '//<code>', '//</code>', props_cpp_fname, True)

    #--------------------------------------------- Update MATLAB file

    # Properties list
    matlab_props_text = ''
    matlab_props_text += '    %%% Auto generated %%%\n'
    matlab_props_text += '    properties\n'
    for prop in matlab_props:
        matlab_props_text += '        ' + prop + '\n'
    matlab_props_text += '    end\n'

    # Setter and getter for each property
    matlab_methods_text = ''
    matlab_methods_text += '    %%% Auto generated %%%\n'
    matlab_methods_text += '    methods\n'
    for prop in matlab_props:
        dtype = prop_dtype[prop]
        is_mat = dtype.find('*') > -1

        # Matrix
        if is_mat:

            matlab_getter = \
                '        % Property getter: ' + prop + ' (' + dtype + ')\n' \
                '        function value = get.' + prop + '(obj)\n' \
                '            len = ' + len_getter_prefix + prop + '();\n' \
                '            value = ' + getter_prefix + prop + '(len);\n' \
                '        end\n\n'

            matlab_setter = \
                '        % Property setter: ' + prop + ' (' + dtype + ')\n' \
                '        function set.' + prop + '(obj, value)\n' \
                '            len = ' + len_getter_prefix + prop + '();\n' \
                '            ' + setter_prefix + prop + '(value, len);\n' \
                '        end\n\n'

        # Simple type
        else:
            matlab_getter = \
                '        % Property getter: ' + prop + ' (' + dtype + ')\n' \
                '        function value = get.' + prop + '(obj)\n' \
                '            value = ' + getter_prefix + prop + '();\n' \
                '        end\n\n'

            matlab_setter = \
                '        % Property setter: ' + prop + ' (' + dtype + ')\n' \
                '        function set.' + prop + '(obj, value)\n' \
                '            ' + setter_prefix + prop + '(value);\n' \
                '        end\n\n'

        matlab_methods_text += matlab_getter
        matlab_methods_text += matlab_setter


    matlab_methods_text += '    end\n'

    write_file = False
    with open(matlab_filename) as f:
        matlab_lines = f.read().splitlines()

    matlab_lines = replace_between_tags(matlab_lines, '%<props>', '%</props>', matlab_props_text)
    matlab_lines = replace_between_tags(matlab_lines, '%<props_methods>', '%</props_methods>', matlab_methods_text)
    write_file = True

    # Replace file contents
    if write_file:
        matlab_file = open(matlab_filename, 'wt')

        for line in matlab_lines:
            matlab_file.write('%s\n' % line)

        matlab_file.close()

#------------------------------- Main -------------------------------

# parser.add_option("-f", "--file", action="store", type="string", dest="filename")
def main():
    global logfile, args

    # Read command line options
    parser = argparse.ArgumentParser()

    # Arguments
    #parser.add_argument('-d',           dest='dir',         default=None,                                   help='pcap folder')
    #parser.add_argument('-s',           dest='subdirs',     action='store_true',    default=True,   help='Process pcap files in subfolders')
    #args = parser.parse_args()

    #
    wcsprm_h = 'wcsprm_ready.h'

    # Create log file based on current date/time
    dir = './' #args.dir
    dtstr = datetime.now().strftime('%Y_%m_%d__%H_%M_%S')
    outdir = '.' #os.path.join(dir, '_check_' + dtstr)
    #mkdirs(outdir)
    logfile = open(os.path.join(outdir, 'util.log'), 'a')

    log('started: ' + dtstr + '  ')
    log('')

    process_header(wcsprm_h)
    log('\n\nDone\n')


if __name__ == '__main__':
    main()

