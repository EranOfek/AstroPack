# Package: #


### answer

Respond to SEND using memmapfile class.


    
    Respond to SEND using memmapfile class.  
      
### cprintf

CPRINTF displays styled formatted text in the Command Window Syntax: count = cprintf(style,format,...)


    
    CPRINTF displays styled formatted text in the Command Window  
      
    Syntax:  
    count = cprintf(style,format,...)  
      
    Description:  
    CPRINTF processes the specified text using the exact same FORMAT  
    arguments accepted by the built-in SPRINTF and FPRINTF functions.  
      
    CPRINTF then displays the text in the Command Window using the  
    specified STYLE argument. The accepted styles are those used for  
    Matlab's syntax highlighting (see: File / Preferences / Colors /  
    M-file Syntax Highlighting Colors), and also user-defined colors.  
      
    The possible pre-defined STYLE names are:  
      
    'Text'                 - default: black  
    'Keywords'             - default: blue  
    'Comments'             - default: green  
    'Strings'              - default: purple  
    'UnterminatedStrings'  - default: dark red  
    'SystemCommands'       - default: orange  
    'Errors'               - default: light red  
    'Hyperlinks'           - default: underlined blue  
      
    'Black','Cyan','Magenta','Blue','Green','Red','Yellow','White'  
      
    STYLE beginning with '-' or '_' will be underlined. For example:  
    '-Blue' is underlined blue, like 'Hyperlinks';  
    '_Comments' is underlined green etc.  
      
    STYLE beginning with '*' will be bold (R2011b+ only). For example:  
    '*Blue' is bold blue;  
    '*Comments' is bold green etc.  
    Note: Matlab does not currently support both bold and underline,  
    only one of them can be used in a single cprintf command. But of  
    course bold and underline can be mixed by using separate commands.  
      
    STYLE colors can be specified in 3 variants:  
    [0.1, 0.7, 0.3] - standard Matlab RGB color format in the range 0.0-1.0  
    [26, 178, 76]   - numeric RGB values in the range 0-255  
    '#1ab34d'       - Hexadecimal format in the range '00'-'FF' (case insensitive)  
    3-digit HTML RGB format also accepted: 'a5f'='aa55ff'  
      
    STYLE can be underlined by prefixing - :  -[0,1,1]  or '-#0FF' is underlined cyan  
    STYLE can be made bold  by prefixing * : '*[1,0,0]' or '*#F00' is bold red  
      
    STYLE is case-insensitive and accepts unique partial strings just  
    like handle property names.  
      
    CPRINTF by itself, without any input parameters, displays a demo  
      
    Example:  
    cprintf;    displays the demo  
    cprintf('text',   'regular black text');  
    cprintf('hyper',  'followed s','by');  
    cprintf('key',    'd colored', 4);  
    cprintf('-comment','& underlined');  
    cprintf('err',    'elements\n');  
    cprintf('cyan',   'cyan');  
    cprintf('_green', 'underlined green');  
    cprintf(-[1,0,1], 'underlined magenta');  
    cprintf([1,0.5,0],'and multi-\nline orange\n');  
    cprintf('*blue',  'and *bold* (R2011b+ only)\n');  
    cprintf('string');   same as fprintf('string') and cprintf('text','string')  
      
    Bugs and suggestions:  
    Please send to Yair Altman (altmany at gmail dot com)  
      
    Warning:  
    This code heavily relies on undocumented and unsupported Matlab  
    functionality. It works on Matlab 7+, but use at your own risk!  
      
    A technical description of the implementation can be found at:  
    <a href="http://undocumentedmatlab.com/blog/cprintf/">http://UndocumentedMatlab.com/blog/cprintf/</a>  
      
    Limitations:  
    1. In R2011a and earlier, a single space char is inserted at the  
    beginning of each CPRINTF text segment (this is ok in R2011b+).  
      
    2. In R2011a and earlier, consecutive differently-colored multi-line  
    CPRINTFs sometimes display incorrectly on the bottom line.  
    As far as I could tell this is due to a Matlab bug. Examples:  
    >> cprintf('-str','under\nline'); cprintf('err','red\n');  hidden 'red', unhidden '_'  
    >> cprintf('str','regu\nlar'); cprintf('err','red\n');  underline red (not purple) 'lar'  
      
    3. Sometimes, non newline ('\n')-terminated segments display unstyled  
    (black) when the command prompt chevron ('>>') regains focus on the  
    continuation of that line (I can't pinpoint when this happens).  
    To fix this, simply newline-terminate all command-prompt messages.  
      
    4. In R2011b and later, the above errors appear to be fixed. However,  
    the last character of an underlined segment is not underlined for  
    some unknown reason (add an extra space character to make it look better)  
      
    5. In old Matlab versions (e.g., Matlab 7.1 R14), multi-line styles  
    only affect the first line. Single-line styles work as expected.  
    R14 also appends a single space after underlined segments.  
      
    6. Bold style is only supported on R2011b+, and cannot also be underlined.  
      
    Change log:  
    2021-04-07: Enabled specifying color as #RGB (hexa codes), [.1,.7,.3], [26,178,76]  
    2020-01-20: Fix by T. Hosman for embedded hyperlinks  
    2015-06-24: Fixed a few discoloration issues (some other issues still remain)  
    2015-03-20: Fix: if command window isn't defined yet (startup) use standard fprintf as suggested by John Marozas  
    2012-08-09: Graceful degradation support for deployed (compiled) and non-desktop applications; minor bug fixes  
    2012-08-06: Fixes for R2012b; added bold style; accept RGB string (non-numeric) style  
    2011-11-27: Fixes for R2011b  
    2011-08-29: Fix by Danilo (FEX comment) for non-default text colors  
    2011-03-04: Performance improvement  
    2010-06-27: Fix for R2010a/b; fixed edge case reported by Sharron; CPRINTF with no args runs the demo  
    2009-09-28: Fixed edge-case problem reported by Swagat K  
    2009-05-28: corrected nargout behavior suggested by Andreas GÃ¤b  
    2009-05-13: First version posted on <a href="http://www.mathworks.com/matlabcentral/fileexchange/authors/27420">MathWorks File Exchange</a>  
      
    See also:  
    sprintf, fprintf  
      
    License to use and modify this code is granted freely to all interested, as long as the original author is  
    referenced and attributed as such. The original author maintains the right to be solely associated with this work.  
      
    Programmed and Copyright by Yair M. Altman: altmany(at)gmail.com  
    $Revision: 1.12 $  $Date: 2021/04/07 01:02:53 $  
      
### doStartup




    
      
### funcarg




    
### ini2struct

Author: Andriy Nych ( nych.andriy@gmail.com ) Version:        733341.4155741782200


    
      
    Author: Andriy Nych ( nych.andriy@gmail.com )  
    Version:        733341.4155741782200  
      
      
    INI = ini2struct(FileName)  
      
    This function parses INI file FileName and returns it as a structure with  
    section names and keys as fields.  
      
    Sections from INI file are returned as fields of INI structure.  
    Each fiels (section of INI file) in turn is structure.  
    It's fields are variables from the corresponding section of the INI file.  
      
    If INI file contains "oprhan" variables at the beginning, they will be  
    added as fields to INI structure.  
      
    Lines starting with ';' and '#' are ignored (comments).  
      
    See example below for more information.  
      
    Usually, INI files allow to put spaces and numbers in section names  
    without restrictions as long as section name is between '[' and ']'.  
    It makes people crazy to convert them to valid Matlab variables.  
    For this purpose Matlab provides GENVARNAME function, which does  
    "Construct a valid MATLAB variable name from a given candidate".  
    See 'help genvarname' for more information.  
      
    The INI2STRUCT function uses the GENVARNAME to convert strange INI  
    file string into valid Matlab field names.  
      
    [ test.ini ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
      
    SectionlessVar1=Oops  
    SectionlessVar2=I did it again ;o)  
    [Application]  
    Title = Cool program  
    LastDir = c:\Far\Far\Away  
    NumberOFSections = 2  
    [1st section]  
    param1 = val1  
    Param 2 = Val 2  
    [Section #2]  
    param1 = val1  
    Param 2 = Val 2  
      
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
      
    The function converts this INI file it to the following structure:  
      
    [ MatLab session (R2006b) ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    >> INI = ini2struct('test.ini');  
    >> disp(INI)  
    sectionlessvar1: 'Oops'  
    sectionlessvar2: 'I did it again ;o)'  
    application: [1x1 struct]  
    x1stSection: [1x1 struct]  
    section0x232: [1x1 struct]  
      
    >> disp(INI.application)  
    title: 'Cool program'  
    lastdir: 'c:\Far\Far\Away'  
    numberofsections: '2'  
      
    >> disp(INI.x1stSection)  
    param1: 'val1'  
    param2: 'Val 2'  
      
    >> disp(INI.section0x232)  
    param1: 'val1'  
    param2: 'Val 2'  
      
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
      
    NOTE.  
    WhatToDoWithMyVeryCoolSectionAndVariableNamesInIniFileMyVeryCoolProgramWrites?  
    GENVARNAME also does the following:  
    "Any string that exceeds NAMELENGTHMAX is truncated". (doc genvarname)  
    Period.  
      
    =  
### inifile

INIFILE Creates, reads, or writes data from/to a standard ini (ascii) file. Such a file is organized into sections ([section name]), subsections(enclosed by {subsection name}), and keys (key=value).  Empty lines and lines with the first non-empty


    
    INIFILE Creates, reads, or writes data from/to a standard ini (ascii)  
    file. Such a file is organized into sections  
    ([section name]), subsections(enclosed by {subsection name}),  
    and keys (key=value).  Empty lines and lines with the first non-empty  
    character being ; (comment lines) are ignored.  
      
    Usage:  
    INIFILE(fileName,'new')  
    Rewrites an existing file - creates a new, empty file.  
      
    INIFILE(fileName,'write',keys,<style>)  
    Writes keys given as cell array of strings (see description of  
    the keys below). Optional style variable: 'tabbed' writes sections,  
    subsections and keys in a tabbed style to get more readable  
    file. The 'plain' style is the default style. This only affects  
    the keys that will be written/rewritten.  
      
    INIFILE(fileName,'deletekeys',keys)  
    Deletes keys and their values - if they exist.  
      
    [readsett,result] = INIFILE(fileName,'read',keys)  
    Reads the values of the keys where readsett is a cell array of  
    strings and/or numeric values of the keys. If any of the keys  
    is not found, the default value is returned (if given in the  
    5-th column of the keys parameter). result is a cell array of  
    strings - one for each key read; empty if OK, error/warning  
    string if error; in both cases an empty string is returned in  
    readsett{i} for the i-th key if error.  
      
    [keys,sections,subsections] = INIFILE(fName,'readall')  
    Reads entire file and returns all the sections, subsections  
    and keys found.  
      
      
    Notes on the keys cell array given as an input parameter:  
    Cell array of STRINGS; either 3, 4, or 5 columns.  
    Each row has the same number of columns. The columns are:  
    'section':      section name string (the root is considered if  
    empty)  
    'subsection':   subsection name string (the root is considered  
    if empty)  
    'key':          name of the field to write/read from (given as  
    a string).  
    value:          (optional) STRING or NUMERIC value (scalar or  
    matrix) to be written to the  
    ini file in the case of 'write' operation OR  
    conversion CHAR for read operation:  
    'i' for integer, 'd' for double, 's' or  
    '' or not given for string (default).  
    defaultValue:   (optional) string or numeric value (scalar or  
    matrix) that is returned when the key is not  
    found or an empty value is found  
    when reading ('read' operation).  
    If the defaultValue is not given and the key  
    is not found, an empty value is returned.  
    It MUST be in the format as given by the  
    value, e.g. if the value = 'i' it must be  
    given as an integer etc.  
      
      
    EXAMPLE:  
    Suppose we want a new ini file, test1.ini with 4 fields, including a  
    5x5 matrix (see below). We can write the 5 fields into the ini file  
    using:  
      
    x = rand(5);     matrix data  
    inifile('test1.ini','new');  
    writeKeys = {'measurement','person','name','Primoz Cermelj';...  
    'measurement','protocol','id',1;...  
    'application','','description.m1','some...';...  
    'application','','description.m2','some...';...  
    'data','','x',x};  
    inifile('test1.ini','write',writeKeys,'plain');  
      
    Later, you can read them out. Additionally, if any of them won't  
    exist, a default value will be returned (if the 5-th column is given  
    for all the rows as below).  
      
    readKeys = {'measurement','person','name','','John Doe';...  
    'measurement','protocol','id','i',0;...  
    'application','','description.m1','','none';...  
    'application','','description.m2','','none';...  
    'data','','x','d',zeros(5)};  
    readSett = inifile('test1.ini','read',readKeys);  
      
    Or, we can just read all the keys out  
    [keys,sections,subsections] = inifile(test1.ini,'readall');  
      
      
    NOTES: If the operation is 'write' and the file is empty or does not  
    exist, a new file is created. When writing and if any of the section  
    or subsection or key does not exist, it creates (adds) a new one.  
    Everything but value is NOT case sensitive. Given keys and values  
    will be trimmed (leading and trailing spaces will be removed).  
    Any duplicates (section, subsection, and keys) are ignored. Empty  
    section and/or subsection can be given as an empty string, '',  
    but NOT as an empty matrix, [].  
      
    Numeric matrices can be represented as strings in one of the two form:  
    '1 2 3;4 5 6' or '1,2,3;4,5,6' (an example).  
      
    Comment lines starts with ; as the first non-empty character but  
    comments can not exist as a tail to a standard, non-comment line as ;  
    is also used as a row delimiter for matrices.  
      
    This function was tested on the win32 platform only but it should  
    also work on Unix/Linux platforms. Since some short-circuit operators  
    are used, at least Matlab 6.5 (R13) is required.  
      
      
    First release on 29.01.2003  
    (c) Primoz Cermelj, Slovenia  
    Contact: primoz.cermelj@gmail.com  
    Download location: http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=2976&objectType=file  
      
    Version: 1.4.2  
    Last revision: 12.01.2007  
      
    Bug reports, questions, etc. can be sent to the e-mail given above.  
      
    ACKNOWLEDGEMENTS: Thanks to Diego De Rosa for a suggestion/fix how to  
    read the value when the key is found but empty.  
      
      
      
    INIFILE history  
      
      
    [v.1.4.2] 12.01.2007  
    - FIX: When in read mode and a certain key is found but the value is  
    empty, the default value will be used instead.  
      
    [v.1.4.1] 12.01.2006  
    - FIX: Some minor refinements (speed,...)  
      
    [v.1.4.0] 05.12.2006  
    - NEW: New 'readall' option added which reads all the sections,  
    subsections and keys out  
      
    [v.1.3.2 - v.1.3.5] 25.08.2004  
    - NEW: Speed improvement for large files - using fread and fwrite instead  
    of fscanf and fprintf, respectively  
    - NEW: Some minor changes  
    - NEW: Writing speed-up  
    - NEW: New-line chars are properly set for pc, unix, and mac  
      
    [v.1.3.1] 04.05.2004  
    - NEW: Comment lines are detected and thus ignored; comment lines are  
    lines with first non-empty character being ;  
    - NEW: Lines not belonging to any of the recognized types (key, section,  
    comment,...) raise an error.  
      
    [v.1.3.0] 21.04.2004  
    - NEW: 2D Numeric matrices can be read/written  
    - FIX: Bug related to read operation and default value has been removed  
      
    [v.1.2.0] 30.04.2004  
    - NEW: Automatic conversion capability (integers, doubles, and strings)  
    added for read and write operations  
      
    [v.1.1.0] 04.02.2004  
    - FIX: 'writetext' option removed (there was a bug previously)  
      
    [v.1.01b] 19.12.2003  
    - NEW: A new concept - multiple keys can now be read, written, or deleted  
    ALL AT ONCE which makes this function much faster. For example, to  
    write 1000 keys, using previous versions it took 157 seconds on a  
    1.5 GHz machine, with this new version it took only 0.9 seconds.  
    In general, the speed improvement is greater when a larger number of  
    read/written keys is considered (with respect to the older version).  
    - NEW: The format of the input parameters has changed. See above.  
      
    [v.0.97] 19.11.2003  
    - NEW: Additional m-function, strtrim, is no longer needed  
      
    [v.0.96] 16.10.2003  
    - FIX: Detects empty keys  
      
    [v.0.95] 04.07.2003  
    - NEW: 'deletekey' option/operation added  
    - FIX: A major file refinement to obtain a more compact utility ->  
    additional operations can "easily" be implemented  
      
    [v.0.91-0.94]  
    - FIX: Some minor refinements  
      
    [v.0.90] 29.01.2003  
    - NEW: First release of this tool  
      
      
      
### inpaint_nans

INPAINT_NANS: in-paints over nans in an array usage: B=INPAINT_NANS(A)           default method usage: B=INPAINT_NANS(A,method)    specify method used


    
    INPAINT_NANS: in-paints over nans in an array  
    usage: B=INPAINT_NANS(A)           default method  
    usage: B=INPAINT_NANS(A,method)    specify method used  
      
    Solves approximation to one of several pdes to  
    interpolate and extrapolate holes in an array  
      
    arguments (input):  
    A - nxm array with some NaNs to be filled in  
      
    method - (OPTIONAL) scalar numeric flag - specifies  
    which approach (or physical metaphor to use  
    for the interpolation.) All methods are capable  
    of extrapolation, some are better than others.  
    There are also speed differences, as well as  
    accuracy differences for smooth surfaces.  
      
    methods {0,1,2} use a simple plate metaphor.  
    method  3 uses a better plate equation,  
    but may be much slower and uses  
    more memory.  
    method  4 uses a spring metaphor.  
    method  5 is an 8 neighbor average, with no  
    rationale behind it compared to the  
    other methods. I do not recommend  
    its use.  
      
    method  0 > (DEFAULT) see method 1, but  
    this method does not build as large of a  
    linear system in the case of only a few  
    NaNs in a large array.  
    Extrapolation behavior is linear.  
      
    method  1 > simple approach, applies del^2  
    over the entire array, then drops those parts  
    of the array which do not have any contact with  
    NaNs. Uses a least squares approach, but it  
    does not modify known values.  
    In the case of small arrays, this method is  
    quite fast as it does very little extra work.  
    Extrapolation behavior is linear.  
      
    method  2 > uses del^2, but solving a direct  
    linear system of equations for nan elements.  
    This method will be the fastest possible for  
    large systems since it uses the sparsest  
    possible system of equations. Not a least  
    squares approach, so it may be least robust  
    to noise on the boundaries of any holes.  
    This method will also be least able to  
    interpolate accurately for smooth surfaces.  
    Extrapolation behavior is linear.  
      
    Note: method 2 has problems in 1-d, so this  
    method is disabled for vector inputs.  
      
    method  3 + See method 0, but uses del^4 for  
    the interpolating operator. This may result  
    in more accurate interpolations, at some cost  
    in speed.  
      
    method  4 + Uses a spring metaphor. Assumes  
    springs (with a nominal length of zero)  
    connect each node with every neighbor  
    (horizontally, vertically and diagonally)  
    Since each node tries to be like its neighbors,  
    extrapolation is as a constant function where  
    this is consistent with the neighboring nodes.  
      
    method  5 + See method 2, but use an average  
    of the 8 nearest neighbors to any element.  
    This method is NOT recommended for use.  
      
      
    arguments (output):  
    B - nxm array with NaNs replaced  
      
      
    Example:  
    [x,y] = meshgrid(0:.01:1);  
    z0 = exp(x+y);  
    znan = z0;  
    znan(20:50,40:70) = NaN;  
    znan(30:90,5:10) = NaN;  
    znan(70:75,40:90) = NaN;  
      
    z = inpaint_nans(znan);  
      
      
    See also: griddata, interp1  
      
    Author: John D'Errico  
    e-mail address: woodchips@rochester.rr.com  
    Release: 2  
    Release date: 4/15/06  
      
      
    I always need to know which elements are NaN,  
    and what size the array is for any method  
### inpaint_nans_bc

INPAINT_NANS_BC: in-paints over nans in an array, with spherical or toroidal boundary conditions usage: B=inpaint_nsns_bc(A)           default method usage: B=inpaint_nsns_bc(A,method)    specify method used usage: B=inpaint_nsns_bc(A,method,bcclass)    specify class of boundary conditions applied


    
    INPAINT_NANS_BC: in-paints over nans in an array, with spherical or toroidal boundary conditions  
    usage: B=inpaint_nsns_bc(A)           default method  
    usage: B=inpaint_nsns_bc(A,method)    specify method used  
    usage: B=inpaint_nsns_bc(A,method,bcclass)    specify class of boundary conditions applied  
      
    Solves approximation to one of several pdes to  
    interpolate and extrapolate holes in an array.  
    Depending upon the boundary conditions specified,  
    the array will effectively be treated as if it lies  
    on either the surface of a sphere or a toroid.  
      
    arguments (input):  
    A - nxm array with some NaNs to be filled in  
      
    method - (OPTIONAL) scalar numeric flag - specifies  
    which approach (or physical metaphor to use  
    for the interpolation.) All methods are capable  
    of extrapolation, some are better than others.  
    There are also speed differences, as well as  
    accuracy differences for smooth surfaces.  
      
    The methods employed here are a subset of the  
    methods of the original inpaint_nans.  
      
    methods {0,1} use a simple plate metaphor.  
    method  4 uses a spring metaphor.  
      
    method  0 > (DEFAULT) see method 1, but  
    this method does not build as large of a  
    linear system in the case of only a few  
    NaNs in a large array.  
    Extrapolation behavior is linear.  
      
    method  1 > simple approach, applies del^2  
    over the entire array, then drops those parts  
    of the array which do not have any contact with  
    NaNs. Uses a least squares approach, but it  
    does not modify known values.  
    In the case of small arrays, this method is  
    quite fast as it does very little extra work.  
    Extrapolation behavior is linear.  
      
    method  4 > Uses a spring metaphor. Assumes  
    springs (with a nominal length of zero)  
    connect each node with every neighbor  
    (horizontally, vertically and diagonally)  
    Since each node tries to be like its neighbors,  
    extrapolation is as a constant function where  
    this is consistent with the neighboring nodes.  
      
    DEFAULT: 0  
      
    bcclass - (OPTIONAL) character flag, indicating how  
    the array boundaries will be treated in the  
    inpainting operation. bcclass may be either  
    'sphere' or 'toroid', or any simple contraction  
    of these words.  
      
    bcclass = 'sphere' > The first and last rows  
    of the array will be treated as if they are  
    at the North and South poles of a sphere.  
    Adjacent to those rows will be singular  
    phantom nodes at each pole.  
      
    bcclass = 'toroid' > The first and last rows  
    of the array will be treated as if they are  
    adjacent to ech other. As well, the first and  
    last columns will be adjacent to each other.  
      
    DEFAULT: 'sphere'  
      
    arguments (output):  
    B - nxm array with NaNs replaced  
      
      
    Example:  
    [x,y] = meshgrid(0:.01:1);  
    z0 = exp(x+y);  
    znan = z0;  
    znan(20:50,40:70) = NaN;  
    znan(30:90,5:10) = NaN;  
    znan(70:75,40:90) = NaN;  
      
    z = inpaint_nans(znan);  
      
      
    See also: griddata, interp1  
      
    Author: John D'Errico  
    e-mail address: woodchips@rochester.rr.com  
    Release: 2  
    Release date: 4/15/06  
      
      
    I always need to know which elements are NaN,  
    and what size the array is for any method  
### inpaintn




    
      
    INPAINTN Inpaint over missing data in N-D array  
    Y = INPAINTN(X) replaces the missing data in X by extra/interpolating  
    the non-missing elements. The non finite values (NaN or Inf) in X are  
    considered as missing data. X can be any N-D array.  
      
    INPAINTN (no input/output argument) runs the following 3-D example.  
      
    Important note:  
      
    INPAINTN uses an iterative process baased on DCT and IDCT.  
    Y = INPAINTN(X,N) uses N iterations. By default, N = 100. If you  
    estimate that INPAINTN did not totally converge, increase N:  
    Y = INPAINTN(X,1000)  
      
    Y = INPAINTN(X,N,Y0) uses Y0 as initial guess. This could be useful if  
    you want to run the process a second time or if you have a GOOD guess  
    of the final result. By default, INPAINTN makes a nearest neighbor  
    interpolation (by using BWDIST) to obtain a rough guess.  
      
    References (please refer to the two following references)  
      
    1) Garcia D, Robust smoothing of gridded data in one and higher  
    dimensions with missing values. Computational Statistics & Data  
    Analysis, 2010;54:1167-1178.  
    <a  
    href="matlab:web('http://www.biomecardio.com/publis/csda10.pdf')">download PDF</a>  
    2) Wang G, Garcia D et al. A three-dimensional gap filling method for  
    large geophysical datasets: Application to global satellite soil  
    moisture observations. Environ Modell Softw, 2012;30:139-142.  
    <a  
    href="matlab:web('http://www.biomecardio.com/publis/envirmodellsoftw12.pdf')">download PDF</a>  
      
    Examples  
      
      
    RGB image  
    onion = imread('onion.png');  
    I = randperm(numel(onion));  
    onionNaN = double(onion); onionNaN(I(1:round(numel(I)*0.5))) = NaN;  
    subplot(211), imshow(uint8(onionNaN)), title('Corrupted image - 50')  
    for k=1:3, onion(:,:,k) = inpaintn(onionNaN(:,:,k)); end  
    subplot(212), imshow(uint8(onion)), title('Inpainted image')  
      
    2-D data  
    n = 256;  
    y0 = peaks(n);  
    y = y0;  
    I = randperm(n^2);  
    y(I(1:n^2*0.5)) = NaN;  lose 1/2 of data  
    y(40:90,140:190) = NaN;  create a hole  
    z = inpaintn(y,200);  inpaint data  
    subplot(2,2,1:2), imagesc(y), axis equal off  
    title('Corrupted data')  
    subplot(223), imagesc(z), axis equal off  
    title('Recovered data ...')  
    subplot(224), imagesc(y0), axis equal off  
    title('... compared with original data')  
      
    3-D data  
    load wind  
    xmin = min(x(:)); xmax = max(x(:));  
    zmin = min(z(:)); ymax = max(y(:));  
    wind velocity  
    vel0 = interp3(sqrt(u.^2+v.^2+w.^2),1,'cubic');  
    x = interp3(x,1); y = interp3(y,1); z = interp3(z,1);  
    remove randomly 90 of the data  
    I = randperm(numel(vel0));  
    velNaN = vel0;  
    velNaN(I(1:round(numel(I)*.9))) = NaN;  
    inpaint using INPAINTN  
    vel = inpaintn(velNaN);  
    display the results  
    subplot(221), imagesc(velNaN(:,:,15)), axis equal off  
    title('Corrupted plane, z = 15')  
    subplot(222), imagesc(vel(:,:,15)), axis equal off  
    title('Reconstructed plane, z = 15')  
    subplot(223)  
    hsurfaces = slice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);  
    set(hsurfaces,'FaceColor','interp','EdgeColor','none')  
    hcont = contourslice(x,y,z,vel0,[xmin,100,xmax],ymax,zmin);  
    set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)  
    view(3), daspect([2,2,1]), axis tight  
    title('Original data compared with...')  
    subplot(224)  
    hsurfaces = slice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);  
    set(hsurfaces,'FaceColor','interp','EdgeColor','none')  
    hcont = contourslice(x,y,z,vel,[xmin,100,xmax],ymax,zmin);  
    set(hcont,'EdgeColor',[.7,.7,.7],'LineWidth',.5)  
    view(3), daspect([2,2,1]), axis tight  
    title('... reconstructed data')  
      
    - 4-D data -  
    [x1,x2,x3,x4] = ndgrid(-2:0.2:2);  
    z0 = x2.*exp(-x1.^2-x2.^2-x3.^2-x4.^2);  
    I = randperm(numel(z0));  
    remove 50 of the data  
    zNaN = z0; zNaN(I(1:round(numel(I)*.5))) = NaN;  
    reconstruct the data using INPAINTN  
    z = inpaintn(zNaN);  
    display the results (for x4 = 0)  
    subplot(211)  
    zNaN(isnan(zNaN)) = 0.5;  
    slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),zNaN(:,:,:,11),...  
    [-1.2 0.8 2],2,[-2 0.2])  
    title('Corrupt data, x4 = 0')  
    subplot(212)  
    slice(x2(:,:,:,1),x1(:,:,:,1),x3(:,:,:,1),z(:,:,:,11),...  
    [-1.2 0.8 2],2,[-2 0.2])  
    title('Reconstructed data')  
      
    See also SMOOTHN, GRIDDATAN  
      
    Damien Garcia  2010/06, last update 2017/08  
    website: <a  
    href="matlab:web('http://www.biomecardio.com/en')">www.BiomeCardio.com</a>  
      
      
### myFunction

Summary Detailed description


    
    Summary  
    Detailed description  
      
### send

Interactively send a message to ANSWER using memmapfile class.


    
    Interactively send a message to ANSWER using memmapfile class.  
      
### test1




    
      
### test2




    
      
### testMyFunction




    
      
### test_mex_writematrix




    
      
    create 'magic square' matrix 5x5  
### test_mex_writematrix2




    
      
    create 'magic square' matrix 5x5  
### test_phonebook




    
      
