/* MEX-file generated by genmex */
#include <math.h>
#include "mex.h"

void MAIN_(){} /* Dummy MAIN for FORTRAN */
#ifdef __GNUC__
/* void MAIN__(){} /* Dummy MAIN for Linux_FORTRAN */
#endif
static char user_routine_name[20][64];

#ifdef MSC
 #define FFUNCALL __stdcall
 #define FFUNPTR __stdcall
 #define ROUTNAME DPCHQA
#else
 #define FFUNCALL 
 #define FFUNPTR *
 #define ROUTNAME dpchqa_
#endif



/* Routine prototype */
extern double FFUNCALL ROUTNAME(
int *n,
double *x,
double *f,
double *d,
double *a,
double *b,
int *ierr
);

/* Argument declaration are global so their values    */
/* can be referred in (possible) argument subprograms */
static int *n;
static double *x;
static double *f;
static double *d;
static double *a;
static double *b;
static int *ierr;


void mexFunction(int gm_nout, mxArray *gm_pout[], int gm_nin, const mxArray *gm_pin[])
{
  int gm_i,gm_j,gm_k,gm_l,gm_m,gm_n;
  double gm_ux_x;

/* Check the number of input and output arguments */
  if (gm_nin != 7) {
    mexErrMsgTxt("Needs 7 input parameters");
  } else if ((gm_nout != 8)) {
    mexErrMsgTxt("Needs 8 output argument");
  }

  gm_l = mxGetM(gm_pin[0])*mxGetN(gm_pin[0]);
  n = (int *) mxCalloc(gm_l,sizeof(int));
  for (gm_i=0;gm_i<gm_l;gm_i++) {
    n[gm_i] = (int) (mxGetPr(gm_pin[0]))[gm_i];
  }
  x = mxGetPr(gm_pin[1]);
  f = mxGetPr(gm_pin[2]);
  d = mxGetPr(gm_pin[3]);
  a = mxGetPr(gm_pin[4]);
  b = mxGetPr(gm_pin[5]);
  gm_l = mxGetM(gm_pin[6])*mxGetN(gm_pin[6]);
  ierr = (int *) mxCalloc(gm_l,sizeof(int));
  for (gm_i=0;gm_i<gm_l;gm_i++) {
    ierr[gm_i] = (int) (mxGetPr(gm_pin[6]))[gm_i];
  }

 /* Ready to call the routine */
  mexSetTrapFlag(0);
  gm_ux_x =
#ifdef MSC
  DPCHQA(n,x,f,d,a,b,ierr);
#else
  dpchqa_(n,x,f,d,a,b,ierr);
#endif

  gm_pout[0] = mxCreateDoubleMatrix(1,1,mxREAL);
  *(mxGetPr(gm_pout[0])) = gm_ux_x;
  gm_n = mxGetN(gm_pin[0]);
  gm_m = mxGetM(gm_pin[0]);
  gm_pout[1] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[1]))[gm_i] = (double) n[gm_i];
  }
  mxFree(n);

  gm_n = mxGetN(gm_pin[1]);
  gm_m = mxGetM(gm_pin[1]);
  gm_pout[2] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[2]))[gm_i] = x[gm_i];
  }

  gm_n = mxGetN(gm_pin[2]);
  gm_m = mxGetM(gm_pin[2]);
  gm_pout[3] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[3]))[gm_i] = f[gm_i];
  }

  gm_n = mxGetN(gm_pin[3]);
  gm_m = mxGetM(gm_pin[3]);
  gm_pout[4] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[4]))[gm_i] = d[gm_i];
  }

  gm_n = mxGetN(gm_pin[4]);
  gm_m = mxGetM(gm_pin[4]);
  gm_pout[5] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[5]))[gm_i] = a[gm_i];
  }

  gm_n = mxGetN(gm_pin[5]);
  gm_m = mxGetM(gm_pin[5]);
  gm_pout[6] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[6]))[gm_i] = b[gm_i];
  }

  gm_n = mxGetN(gm_pin[6]);
  gm_m = mxGetM(gm_pin[6]);
  gm_pout[7] = mxCreateDoubleMatrix(gm_m,gm_n,mxREAL);
  gm_l = gm_n*gm_m;
  for (gm_i=0;gm_i<gm_l;gm_i++) {
     (mxGetPr(gm_pout[7]))[gm_i] = (double) ierr[gm_i];
  }
  mxFree(ierr);


}
